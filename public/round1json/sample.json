[
    {
        "questionid" : "1",
        "difficulty":"1Easy",
        "description":"<p>&nbsp;Given an expression string <strong>x</strong>. Examine whether the pairs and the orders of &ldquo;{&ldquo;,&rdquo;}&rdquo;,&rdquo;(&ldquo;,&rdquo;)&rdquo;,&rdquo;[&ldquo;,&rdquo;]&rdquo; are correct in exp.<br />For example, the function should return 'true' for exp = &ldquo;[()]{}{[()()]()}&rdquo; and 'false' for exp = &ldquo;[(])&rdquo;.<br></br><hr><p><strong>Example 1:</strong></p><strong>Input</strong>   :  {([])}<br><strong>Output </strong> :  true<br><strong>Explanation</strong> : { ( [ ] ) }.&nbsp;Same kind of brackets can form balaced pairs, with <br>0 number of unbalanced bracket.<p></p></p><p><br><hr><strong>Exapmle 2 :</strong><br><strong>Input</strong> : ()<br><strong>Output </strong> : true<br><strong>Explanation </strong> : (). Same bracket can form balanced pairs,and here <br>only 1 type of bracket is present and in<br>balanced way<p></p><br><hr><p><strong>Example 3:</strong></p><strong>Input </strong> : ([]<br><strong>Output  </strong> : false<br><strong>Explanation </strong> : ([]. Here square bracket is balanced but the<br> small bracket is not balanced and <br>Hence , the output will be unbalanced.<p></p><br><hr><strong>Constraints:</strong><br />1 &le; |x| &le; 32000<p></p></p>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "1wrongcode.cpp",
        "rightcodefile" : "1rightcode.cpp"
    },
    {
        "questionid" : "2",
        "difficulty":"2Hard",
        "description":"Given a string <strong>S</strong> consisting of only opening and closing curly brackets<strong> '{'</strong> and<strong> '}',</strong>&nbsp;find out the minimum&nbsp;number of reversals required to convert the string into a balanced expression.<br />A reversal means changing <strong>'{'</strong> to <strong>'}'</strong> or vice-versa.<p></p><br><hr><p>Example 1&nbsp;:</strong><strong><br>Input&nbsp;:&nbsp;</strong>S = <strong>{&nbsp;{&nbsp;{&nbsp;}&nbsp;}&nbsp;{&nbsp;{&nbsp;{</strong><strong><br>Output&nbsp;:&nbsp;</strong>&nbsp; 2<strong><br>Explanation</strong>&nbsp;:&nbsp;<br> One way to balance is:<strong>{&nbsp;</strong>{&nbsp;{&nbsp;}&nbsp;}&nbsp;<strong>{&nbsp;}&nbsp;}</strong>. There is no balanced sequence that can be formed in lesser reversals.<br><hr><strong>Exapmle&nbsp; :&nbsp;2 <br>Input</strong>&nbsp;:&nbsp;S = {&nbsp;{&nbsp;}&nbsp;{&nbsp;{&nbsp;{&nbsp;}&nbsp;{&nbsp;{&nbsp;}&nbsp;}&nbsp;{&nbsp;{&nbsp;<strong><br>Output:</strong> -1<strong><br>Explanation</strong>: There's no way we can balancethis sequence of braces.<br><hr><p><strong>Expected Time Complexity:&nbsp;</strong>O(|S|).<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(1).</p><p><strong>Constraints:</strong><br />1 &le; |S| &le; 10<sup>5</sup></p>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "2wrongcode.cpp",
        "rightcodefile" : "2rightcode.cpp"
    },
    {
        "questionid" : "3",
        "difficulty":"3Hard",
        "description":"<p>Given a string<strong> S </strong>delete the characters which are appearing more than once consecutively.</p><br><hr><br><p><strong>Example 1:</strong></p><strong>Input:</strong>S = aabb<strong><br>Output:  </strong>ab <strong><br>Explanation:<br></strong> 'a' at 2nd position isappearing 2nd time consecutively.Similiar explanation for b at 4th position.<br><br><hr><br><p><strong>Example 2:</strong><strong><br>Input</strong> : S = aabaa<strong><br>Output:</strong>  aba <strong><br>Explanation:</strong> 'a' at 2nd position is appearing 2nd time consecutively.'a' at fifth position is appearing 2nd time consecutively.</p><p><strong><br><hr><br>GUID:</strong><br />Code starts from&nbsp; the function <strong>removeConsecutiveCharacter()</strong> which accepts a string as input parameter and <strong>returns</strong> modified string. try and find out a (there could be many) invalid test case which will not work out with this solution for current question&nbsp;</p><p><strong><br><hr>Constraints:</strong><br />1&lt;=|S|&lt;=10<sup>5</sup><br />All characters are lowercase alphabets.</p>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "3wrongcode.cpp",
        "rightcodefile" : "3rightcode.cpp"
    },
    {
        "questionid" : "4",
        "difficulty":"4Hard",
        "description":"<p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p><ul><li>For example, <code>&quot0.1.2.201&quot</code> and <code>&quot192.168.1.1&quot</code> are <strong>valid</strong> IP addresses, but <code>&quot0.011.255.245&quot</code>, <code>&quot192.168.1.312&quot</code> and <code>&quot192.168@1.1&quot</code> are <strong>invalid</strong> IP addresses.</li></ul><p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into </em><code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p><br><hr><p><strong>Example 1:</strong></p><p><strong>Input:</strong> s = &quot25525511135&quot</p><strong>Output:</strong> [&quot255.255.11.135&quot,&quot255.255.111.35&quot]<p><strong><br><hr>Example 2:</strong></p><p><strong>Input:</strong> s = &quot1111&quot</p><p><strong>Output:</strong> [&quot1.1.1.1&quot]</p><br><hr><p><strong>Example 3:</strong></p><p><strong>Input:</strong> s = &quot144&quot</p><p><strong>Output:</strong> [&quot&quot]</p><p><strong>Explanation: size of string is less than 4 so it could not be converted into a valid IP .</strong></p><p><strong></strong></p><p><strong><br><hr>Example 4:</strong></p><p><strong>Input:</strong> s = &quot74574377238232&quot</p><p><strong>Output:</strong> [&quot&quot]</p><p><strong>Explanation: size of string is less greater than 12 so it could not be converted into a valid IP .</strong></p><p><strong></strong></p>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "4wrongcode.cpp",
        "rightcodefile" : "4rightcode.cpp"
    },
    {
        "questionid" : "5",
        "difficulty":"5Hard",
        "description":"<p>&nbsp;</p><p>A parentheses string is a <strong>non-empty</strong> string consisting only of '(' and ')'. It is valid if <strong>any</strong> of the following conditions is <strong>true</strong>:</p><ul><li>It is ().</li><li>It can be written as AB (A concatenated with B), where A and B are valid parentheses strings.</li><li>It can be written as (A), where A is a valid parentheses string.</li></ul><p>You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For <strong>each</strong> index i of locked,</p><ul><li>If locked[i] is '1', you <strong>cannot</strong> change s[i].</li><li>But if locked[i] is '0', you <strong>can</strong> change s[i] to either '(' or ')'.</li></ul><p>Return true <em>if you can make s a valid parentheses string</em>. Otherwise, return false.</p><br><hr><br><strong>Example 1:</strong><strong><br>Input:</strong> s = &quot;))()))&quot;, locked = &quot;010100&quot;<strong><br>Output:</strong> true<strong><br>Explanation:</strong> locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.<br><br><hr><br><p><strong>Example 2:</strong> <strong><br>Input:</strong> s = &quot;()()&quot;, locked = &quot;0000&quot; <strong><br>Output:</strong> true <strong><br>Explanation:</strong> We do not need to make any changes because s is already valid.</p><br><hr><strong>Example 3:</strong><strong><br>Input:</strong> s = &quot;)&quot;, locked = &quot;0&quot;<strong><br>Output:</strong> false<strong><br>Explanation:</strong> locked permits us to change s[0]. Changing s[0] to either '(' or ')' will not make s valid.<br><br><hr><br><p><strong>Constraints:</strong></p><ul><li><code>n == s.length == locked.length</code></li><li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li><li><code>s[i]</code> is either <code>'('</code> or <code>')'</code>.</li><li><code>locked[i]</code> is either '0' or 1'.</li></ul>",
        "wrongcode":"#include<iostream>\nusing namespace std;\nint main(){\n\tcout << \"Hello World\";\n\treturn 0;\n}\n",
        "wrongcodefile" : "5wrongcode.cpp",
        "rightcodefile" : "5rightcode.cpp"
    }
]